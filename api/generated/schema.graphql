### This file was generated by Nexus Schema
### Do not make changes to this file directly


input AcceptContactInvitationInput {
  contactInfoMessage: String!
  serverSecret: String!
  signature: String!
  userId: String!
  userSigningKey: String!
}

type AcceptContactInvitationResult {
  contactInvitation: ContactInvitation
}

input AddCollaboratorToRepositoriesInput {
  contactId: ID!
  repositoryGroupMessages: [MultiRepositoryGroupMessagesInput!]
}

type AddCollaboratorToRepositoriesResult {
  entries: [AddCollaboratorToRepositoriesResultEntry]
}

type AddCollaboratorToRepositoriesResultEntry {
  groupSessionMessageIds: [ID]
  repositoryId: ID
}

input AddDeviceInput {
  device: DeviceInput!
  serverSecret: String!
  verificationMessage: String!
}

type AddDeviceResult {
  success: Boolean
}

type AddDeviceVerification {
  verificationMessage: String
}

input AddUserToLicenseInput {
  licenseId: ID!
  userId: ID!
}

type AddUserToLicenseResult {
  license: License
}

input AuthenticateBillingAccountInput {
  emailToken: String!
}

type AuthenticateBillingAccountResult {
  success: Boolean
}

type BillingAccount {
  allLicenses: [License]
  email: String
  id: ID
  paddleCancelUrl: String
  paddleUpdateUrl: String
}

enum BillingAccountSuscriptionStatus {
  ACTIVE
  INACTIVE
}

input ClaimOneTimeKeysForMultipleDevicesInput {
  deviceIdKeys: [String!]
  requestId: String
}

type ClaimOneTimeKeysForMultipleDevicesResult {
  oneTimeKeysWithDeviceIdKey: [OneTimeKeyWithDeviceIdKey]
}

input CompleteContactInvitationInput {
  contactInvitationId: String!
  signature: String!
  userId: String!
  userSigningKey: String!
}

type CompleteContactInvitationResult {
  contactInvitation: ContactInvitation
}

input ConnectToLicenseInput {
  licenseToken: ID!
}

type ConnectToLicenseResult {
  licenseToken: String
}

type Contact {
  contactSigningKey: String
  contactUserId: ID
  id: ID
  signatures: [String]
  signingKey: String
}

type ContactInvitation {
  acceptedByUserId: ID
  contactInfoMessage: String
  id: ID
  status: String
}

type Content {
  authorDevice: Device
  authorUserId: ID
  createdAt: String
  encryptedContent: String
  groupSessionMessage: GroupSessionMessage
  id: ID
  schemaVersion: Int
  schemaVersionSignature: String
}

input ContentInput {
  encryptedContent: String!
  groupSessionMessages: [GroupSessionMessageInput]
  schemaVersion: Int
  schemaVersionSignature: String
}

input CreateContactInvitationInput {
  serverSecret: String!
}

type CreateContactInvitationResult {
  contactInvitation: ContactInvitation
}

input CreateRepositoryInput {
  content: ContentInput!
}

type CreateRepositoryResult {
  groupSessionMessageIds: [ID]
  repository: Repository
}

input CreateUserInput {
  device: DeviceInput!
  signingKey: String!
}

type CreateUserResult {
  user: User
}

input DeleteContactInput {
  contactId: ID!
}

input DeleteContactInvitationInput {
  contactInvitationId: ID!
}

type DeleteContactInvitationResult {
  success: Boolean
}

type DeleteContactResult {
  success: Boolean
}

input DeleteDeviceInput {
  deviceIdKey: ID!
}

type DeleteDeviceResult {
  success: Boolean
}

input DeleteRepositoryInput {
  repositoryId: ID!
}

type DeleteRepositoryResult {
  success: Boolean
}

input DeleteUserInput {
  userId: ID
}

type DeleteUserResult {
  success: Boolean
}

type Device {
  id: ID
  idKey: String
  oneTimeKeys: [OneTimeKey]
  signatures: [String]
  signingKey: String
  userId: String
}

input DeviceInput {
  fallbackKey: String!
  fallbackKeySignature: String!
  idKey: String!
  oneTimeKeys: [OneTimeKeyInput!]
  signature: String!
  signingKey: String!
}

type DeviceTombstone {
  id: ID
  idKey: String
}

input DisconnectFromLicenseInput {
  licenseToken: ID!
}

type DisconnectFromLicenseResult {
  success: Boolean
}

type GroupSessionMessage {
  body: String
  id: ID
  targetDeviceIdKey: String
  type: Int
}

input GroupSessionMessageInput {
  body: String!
  targetDeviceIdKey: String!
  type: Int!
}

input LastContentUpdateIntegrityIdByRepository {
  lastContentUpdateIntegrityId: String!
  repositoryId: ID!
}

type License {
  createdAt: String
  id: ID
  token: String
  userId: String
}

type LicenseToken {
  isActive: Boolean
  subscriptionPlan: SubscriptionPlan
  token: String
}

type LogoutBillingAccountResult {
  success: Boolean
}

input MultiRepositoryGroupMessagesInput {
  groupSessionMessages: [GroupSessionMessageInput]
  repositoryId: ID!
}

type Mutation {
  acceptContactInvitation(input: AcceptContactInvitationInput!): AcceptContactInvitationResult
  addCollaboratorToRepositories(input: AddCollaboratorToRepositoriesInput!): AddCollaboratorToRepositoriesResult
  addDevice(input: AddDeviceInput!): AddDeviceResult
  addUserToLicense(input: AddUserToLicenseInput!): AddUserToLicenseResult
  authenticateBillingAccount(input: AuthenticateBillingAccountInput!): AuthenticateBillingAccountResult
  claimOneTimeKeysForMultipleDevices(input: ClaimOneTimeKeysForMultipleDevicesInput!): ClaimOneTimeKeysForMultipleDevicesResult
  completeContactInvitation(input: CompleteContactInvitationInput!): CompleteContactInvitationResult
  connectToLicense(input: ConnectToLicenseInput!): ConnectToLicenseResult
  createContactInvitation(input: CreateContactInvitationInput!): CreateContactInvitationResult
  createRepository(input: CreateRepositoryInput!): CreateRepositoryResult
  createUser(input: CreateUserInput!): CreateUserResult
  deleteContact(input: DeleteContactInput!): DeleteContactResult
  deleteContactInvitation(input: DeleteContactInvitationInput!): DeleteContactInvitationResult
  deleteDevice(input: DeleteDeviceInput!): DeleteDeviceResult
  deleteRepository(input: DeleteRepositoryInput!): DeleteRepositoryResult
  deleteUser(input: DeleteUserInput!): DeleteUserResult
  disconnectFromLicense(input: DisconnectFromLicenseInput!): DisconnectFromLicenseResult
  logoutBillingAccount: LogoutBillingAccountResult
  refreshLicenseTokenAndRemoveUser(input: RefreshLicenseTokenAndRemoveUserInput!): RefreshLicenseTokenAndRemoveUserResult
  removeCollaboratorFromRepository(input: RemoveCollaboratorFromRepositoryInput!): RemoveCollaboratorFromRepositoryResult
  removeOneTimeKey(input: RemoveOneTimeKeyInput!): RemoveOneTimeKeyResult
  sendBillingAccountAuthEmail(input: SendBillingAccountAuthEmailInput!): SendBillingAccountAuthEmailResult
  sendOneTimeKeys(input: SendOneTimeKeysInput!): SendOneTimeKeysResult
  updatePrivateInfo(input: UpdatePrivateInfoInput!): UpdatePrivateInfoResult
  updateRepositoryContent(input: UpdateRepositoryContentInput!): UpdateRepositoryContentResult
  updateRepositoryContentAndGroupSession(input: UpdateRepositoryContentAndGroupSessionInput!): UpdateRepositoryContentAndGroupSessionResult
}

type OneTimeKey {
  key: String
  signature: String
}

input OneTimeKeyInput {
  key: String!
  signature: String!
}

type OneTimeKeyWithDeviceIdKey {
  deviceIdKey: String
  oneTimeKey: OneTimeKey
}

type PrivateInfo {
  privateInfoContent: [PrivateInfoContent]
}

type PrivateInfoContent {
  authorDevice: Device
  encryptedContent: String
  privateInfoGroupSessionMessage: PrivateInfoGroupSessionMessage
}

type PrivateInfoGroupSessionMessage {
  body: String
  id: ID
  targetDeviceIdKey: String
  type: Int
}

input PrivateInfoGroupSessionMessageInput {
  body: String!
  targetDeviceIdKey: String!
  type: Int!
}

type Query {
  allDeviceTombstones: [DeviceTombstone]
  allLicenseTokens: [LicenseToken]
  allRepositories(lastContentUpdateIntegrityIdsByRepository: [LastContentUpdateIntegrityIdByRepository]): [RepositoryResult]
  billingAccount: BillingAccount
  contactInvitations: [ContactInvitation]
  contacts: [Contact]
  devices: [Device]
  devicesForContact(contactId: ID!): [Device]
  devicesForContactInvitation(serverSecret: String!, userId: ID!, userSigningKey: String!): [Device]
  fetchAddDeviceVerification(deviceIdKey: String!, serverSecret: String!): AddDeviceVerification
  privateInfo: PrivateInfo
  repository(id: ID!): RepositoryResult @deprecated(reason: "Use `repositoryDevices` instead")
  repositoryDevices(groupSessionMessageIds: [ID!]!, repositoryId: ID!): RepositoryDevicesResult
  unclaimedOneTimeKeysCount(deviceIdKey: String): Int
}

input RefreshLicenseTokenAndRemoveUserInput {
  licenseId: ID!
}

type RefreshLicenseTokenAndRemoveUserResult {
  license: License
}

input RemoveCollaboratorFromRepositoryInput {
  collaboratorId: ID!
  repositoryId: ID!
}

type RemoveCollaboratorFromRepositoryResult {
  repository: Repository
}

input RemoveOneTimeKeyInput {
  key: String!
}

type RemoveOneTimeKeyResult {
  success: Boolean
}

type Repository {
  collaborators: [User]
  content: [Content]
  id: ID
  isCreator: Boolean
  lastContentUpdateIntegrityId: String
}

type RepositoryDevicesResult {
  devices: [Device]
  groupSessionMessageIdsMatchTargetDevices: Boolean
}

input RepositoryGroupMessagesInput {
  groupSessionMessage: GroupSessionMessageInput!
  repositoryId: ID!
}

union RepositoryResult = Repository | RepositoryTombstone

type RepositoryTombstone {
  id: ID
}

input SendBillingAccountAuthEmailInput {
  email: String!
}

type SendBillingAccountAuthEmailResult {
  success: Boolean
}

input SendOneTimeKeysInput {
  oneTimeKeys: [OneTimeKeyInput!]
}

type SendOneTimeKeysResult {
  device: Device
}

enum SubscriptionPlan {
  PERSONAL_PRO
  TEAM
}

input UpdatePrivateInfoInput {
  encryptedContent: String!
  privateInfoGroupSessionMessages: [PrivateInfoGroupSessionMessageInput]
}

type UpdatePrivateInfoResult {
  privateInfoContent: PrivateInfoContent
}

input UpdateRepositoryContentAndGroupSessionInput {
  encryptedContent: String!
  groupSessionMessages: [GroupSessionMessageInput]
  repositoryId: ID!
  schemaVersion: Int
  schemaVersionSignature: String
}

type UpdateRepositoryContentAndGroupSessionResult {
  content: Content
  groupSessionMessageIds: [ID]
}

input UpdateRepositoryContentInput {
  encryptedContent: String!
  groupSessionMessageIds: [ID!]
  repositoryId: ID!
  schemaVersion: Int
  schemaVersionSignature: String
}

type UpdateRepositoryContentResult {
  content: Content
}

type User {
  devices: [Device]
  id: ID
}
